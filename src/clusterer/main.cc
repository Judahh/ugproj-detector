#include "../structure.h"
#include "clusterer.h"
#include "visualizer.h"

#include <opencv2/highgui/highgui.hpp>
#include <math.h>
#include <complex>

cv::Mat norm_0_255(const cv::Mat& src){
    cv::Mat dst;
    switch(src.channels()){
        case 1:
            cv::normalize(src,dst,0,255,cv::NORM_MINMAX, CV_8UC1);
            break;
        case 3:
            cv::normalize(src,dst,0,255,cv::NORM_MINMAX, CV_8UC3);
            break;
        default:
            src.copyTo(dst);
            break;
    }
    return dst;
}

int main(int argc, const char** argv) {
  try {
    ugproj::Configuration cfg;
    if (cfg.load(argc, argv)) {
      return 1;
    }

    ugproj::FileWriter writer;
    if (writer.init(cfg)) {
      throw new std::exception();
    }

    // TODO: Load face tracklets and frame index - frame position mapping from
    // output files from tracker.
    //
    // Assigned to: Naing0126
    ugproj::ClustererFileInput input;
    if (input.open(cfg)) {
      throw new std::exception();
    }

    // Mapping between frame indices and frame positions.
    const std::vector<unsigned long>& tracked_positions =
        input.tracked_positions();
    // Face tracklets generated by tracker.
    const std::vector<ugproj::FaceTracklet>& tracklets =
        input.tracklets();

    // TODO: Run dimensionality reduction on faces in face tracklets using PCA.
    //
    // Assigned to: Naing0126

    std::vector<cv::Mat> faceSet;
    std::vector<int> labelSet;

    // Change to grey scale image
    int faceCnt = 0;
    for(ugproj::FaceTracklet tracklet : tracklets){
      const auto iterators = tracklet.face_iterators();
      for(auto it = iterators.first; it != iterators.second; ++it){
        const ugproj::Face& f = *it;
        cv::Mat greyFace, colorFace;
        colorFace = f.get_image();
        cv::cvtColor(colorFace, greyFace, CV_BGR2GRAY);

        faceSet.push_back(greyFace);
        labelSet.push_back(faceCnt++);
      }
    }

    int height = faceSet[0].rows;
    cv::Mat testSample = faceSet[faceSet.size()-1];
    int testLabel = labelSet[faceSet.size()-1];

    // Find EigenFace
    cv::Ptr<cv::FaceRecognizer> model = cv::createEigenFaceRecognizer();
    model->train(faceSet, labelSet);

    cv::Mat eigenvalues = model->getMat("eigenvalues");
    cv::Mat W = model->getMat("eigenvectors");
    cv::Mat mean = model->getMat("mean");

    std::cout << "eigenvalues " << eigenvalues.size() << " eigenvectors " << W.size() << W.type() << std::endl;

    std::cout << "eigenvector cols " << W.cols << std::endl;
    // Display Eigenfaces
    for(int i=0;i<std::min(10,W.cols);i++){
      cv::Mat ev = W.col(i).clone();

      cv::Mat grayscale = norm_0_255(ev.reshape(1,height));
      cv::Mat cgrayscale;
      applyColorMap(grayscale, cgrayscale, cv::COLORMAP_JET);
      char filename[1024];
      std::sprintf(filename,"eigenface_%d.png",i);
      writer.write_image(cgrayscale,filename);
    }

    // Display the image reconstruction
    for(int num_components = std::min(W.cols, 10); num_components < std::min(W.cols, 300); num_components += 15){
      cv::Mat evs = cv::Mat(W, cv::Range::all(), cv::Range(0,num_components));
      cv::Mat projection = subspaceProject(evs, mean, faceSet[0].reshape(1,1));
      cv::Mat reconstruction = subspaceReconstruct(evs, mean, projection);

      reconstruction = norm_0_255(reconstruction.reshape(1, height));
      char filename[1024];
      std::sprintf(filename,"eigenface_reconstruction_%d.png",num_components);
      writer.write_image(reconstruction,filename);
    }

    // Converts the images into a (n x d) matrix
    int rtype = CV_64FC1;
    double alpha = 1, beta = 0;
    // Number of samples
    size_t n = faceSet.size();
    // dimensionality of (reshaped) samples
    size_t d = faceSet[0].total();
    // resulting data matrix
    cv::Mat faces(n, d, rtype);
    int i;
    for(i = 0; i < n; i++){
      if(faceSet[i].empty()){
        std::string error_message = cv::format("Image number %d was empty",i);
        CV_Error(CV_StsBadArg, error_message);
      }
      if(faceSet[i].total() != d){
        std::string error_message = cv::format("Wrong number of elements in matrix #%d!",i);
        CV_Error(CV_StsBadArg, error_message);
      }
      cv::Mat xi = faces.row(i);
      if(faceSet[i].isContinuous()){
        faceSet[i].reshape(1,1).convertTo(xi, rtype, alpha, beta);
      }else{
        faceSet[i].clone().reshape(1,1).convertTo(xi, rtype, alpha, beta);
      }
    }

    std::cout << "faces " << faces.size() << faces.type() << std::endl;

    // Implement weight
    cv::Mat weights = faces * W;
    std::cout << "weights " << weights.size() << " cols " << weights.cols << std::endl;
  
    // Calculate Affinity Matrix
    cv::Mat affinity(weights.rows,weights.rows,CV_32FC1);

    for(int i=0;i<weights.rows;i++){
      for(int j=0;j<weights.rows;j++){
          cv::Mat temp = weights.row(i) - weights.row(j);
          
          std::vector<double> distance;
          temp.copyTo(distance);
          double sum = 0;
          for(int k=0;k<distance.size();k++){
            sum += distance[k]*distance[k];
          }
          affinity.at<double>(i,j) = std::sqrt(sum);
          std::cout << i <<"," << j  <<" - " << affinity.at<double>(i,j) << std::endl;
      }
    }

    for(int i=0;i<weights.rows;i++){
      for(int j=0;j<weights.rows;j++){
          std::cout << i <<"," << j  <<" - " << affinity.at<double>(i,j) << std::endl;
      }
    }
    //completeSymm(affinity);
    std::cout << "affinity " << affinity.size() << std::endl;

    cv::Mat degree(1, affinity.cols, CV_32FC1);
        std::cout << "degree " << degree.size() << std::endl;

    for(int col = 0;col < 100 ; col++){
       // std::cout << col << " " << affinity.col(col).size() << " " << affinity.at<double>(col,0) << std::endl;
        //std::cout << "degree " << degree.at<double>(0,col) << std::endl;
        
        for(int row = 0;row < affinity.rows; row++){
          degree.at<float>(0,col) += affinity.at<double>(col,row);
      //    std::cout << col << ", " << row << ",sum " << affinity.at<double>(99,411) << std::endl;
        }
        //std::cout << "complete " << degree.at<float>(0,col) << std::endl;
    }
    //for(int col = 0; col < 100; col++)
        //std::cout << degree.at<float>(0,col) <<",";
    /*
    // Calculate Laplacian matrix
    cv::Mat L = cv::Mat::diag(degree) - affinity;
    cv::Mat degree_05;
    pow( degree, -0.5, degree_05 );
    degree_05 = cv::Mat::diag( degree_05 );
    L = (degree_05 * L) * degree_05;
    std::cout << "Laplacian " << L.size() << std::endl;
    */
    /*
    // Matrix that includes the result of PCA. Each row represents a face. The
    // order of faces should follow that of face tracklets and that of faces in
    // a tracklet.
    // i.e. Given tracklet #1 {face #1, face #2}, tracklet #2 {face #3},
    // repr_faces_reduced should have dimensionality-reduced vector for
    // face #1, face #2, and face #3 in order, from the first row.
    cv::Mat faces_reduced;
    cv::PCA pca(faces, cv::noArray(), CV_PCA_DATA_AS_ROW, 64);
    faces_reduced = pca.project(faces);

    std::cout << faces_reduced.size() << std::endl;


    // TODO: Make clusterer accept tracklet information and assign a cluster
    // label to each tracklet by voting.
    //
    // Assigned to: kyukyukyu

    // List of cluster IDs for face tracklets.
    std::vector<int> cluster_ids;
    // Clusterer object for faces.
    ugproj::FaceClusterer clusterer(cfg);
    clusterer.do_clustering(faces_reduced, tracklets, &cluster_ids);

    // Writes the visualization of result of clustering to multiple files.
    ugproj::FaceClustersVisualizer visualizer(cfg, &writer);
    visualizer.visualize(tracked_positions, tracklets,
                         cfg.clustering.k, cluster_ids);
    */
  } catch (std::exception*) {
    return 1;
  }
  return 0;
}
