#include "../structure.h"
#include "clusterer.h"
#include "vectorizer.h"
#include "visualizer.h"

#include <opencv2/highgui/highgui.hpp>
#include <math.h>
#include <complex>

cv::Mat norm_0_255(const cv::Mat& src){
    cv::Mat dst;
    switch(src.channels()){
        case 1:
            cv::normalize(src,dst,0,255,cv::NORM_MINMAX, CV_8UC1);
            break;
        case 3:
            cv::normalize(src,dst,0,255,cv::NORM_MINMAX, CV_8UC3);
            break;
        default:
            src.copyTo(dst);
            break;
    }
    return dst;
}

int main(int argc, const char** argv) {
  try {
    ugproj::Configuration cfg;
    if (cfg.load(argc, argv)) {
      return 1;
    }

    ugproj::FileWriter writer;
    if (writer.init(cfg)) {
      throw new std::exception();
    }

    // TODO: Load face tracklets and frame index - frame position mapping from
    // output files from tracker.
    //
    // Assigned to: Naing0126
    ugproj::ClustererFileInput input;
    if (input.open(cfg)) {
      throw new std::exception();
    }

    // Mapping between frame indices and frame positions.
    const std::vector<unsigned long>& tracked_positions =
        input.tracked_positions();
    // Face tracklets generated by tracker.
    const std::vector<ugproj::FaceTracklet>& tracklets =
        input.tracklets();

    // Represent faces in vectors based on the results of Flandmark.
    ugproj::FlandmarkVectorizer vectorizer(cfg, input.flm_model());
    // Matrix that contains vectorized faces. Each row corresponds to a face.
    cv::Mat faces_vectorized = vectorizer.vectorize(tracklets);

    // Compute affinity matrix.

    // Affinity matrix.
    cv::Mat affinity;
    // The number of faces.
    const auto n_faces = faces_vectorized.rows;
    // Parameter that controls the width of neighborhoods.
    const double sigma = 0.2;
    affinity.create(n_faces, n_faces, CV_64FC1);
    for (int i = 0; i < n_faces; ++i) {
      affinity.at<double>(i, i) = std::exp(0.0);
      for (int j = i + 1; j < n_faces; ++j) {
        double norm;
        cv::Mat diff = faces_vectorized.row(i) - faces_vectorized.row(j);
        norm = cv::norm(diff);
        affinity.at<double>(i, j) = affinity.at<double>(j, i) =
            std::exp(-(norm * norm) / (2 * sigma * sigma));
      }
    }

    // Run normalized spectral clustering according to Ng, Jordan, and Weiss
    // (2002).
    // == Start of normalized spectral clustering. ============================

    // Compute degree matrix D.

    // Degree vector deg.
    cv::Mat deg(1, affinity.cols, CV_64FC1);
    // Degree matrix D, which is diagonalized version of deg.
    cv::Mat D;
    for (int i = 0; i < affinity.cols; ++i) {
      // Degree for node i.
      double deg_i = 0.0;
      for (int j = 0; j < affinity.rows; ++j) {
        deg_i += affinity.at<double>(i, j);
      }
      deg.at<double>(0, i) = deg_i;
    }
    D = cv::Mat::diag(deg);
    deg.release();

    // Calculate normalized Laplacian matrix.

    // Laplacian matrix L.
    cv::Mat L = D - affinity;
    affinity.release();
    // D^-(1/2). m stands for 'minus', and o stands for point. (.)
    cv::Mat D_mo5;
    // Normalized Laplacian matrix L_sym.
    cv::Mat L_sym;
    // Eigenvalues and corresponding eigenvectors of L_sym. Eigenvalues are
    // stored in the descending order, and eigenvectors are stored in the same
    // order.
    cv::Mat eval_L_sym, evec_L_sym;
    // Compute D^-(1/2).
    cv::pow(D, 0.5, D_mo5);
    D_mo5 = D_mo5.inv();
    D.release();
    // Normalize L.
    L_sym = (D_mo5 * L) * D_mo5;
    L.release();
    // Compute eigenvalues and eigenvectors of L_sym.
    cv::eigen(L_sym, eval_L_sym, evec_L_sym);

    // Compute matrix U whose columns are top k eigenvectors of L_sym, then
    // form a matrix T from U by normalizing the rows to norm 1.

    // Matrix U.
    cv::Mat U = evec_L_sym.rowRange(0, 64).t();
    // Matrix T.
    cv::Mat T;
    // Temporary matrix for each row of T.
    cv::Mat T_row;
    T.create(U.size(), CV_64FC1);
    T_row.create(1, U.cols, CV_64FC1);
    // L2-normalize each row of U and stores them into T.
    for (int i = U.rows - 1; i >= 0; --i) {
      cv::normalize(U.row(i), T_row);
      T_row.copyTo(T.row(i));
    }
    U.release();
    T_row.release();

    // Make clusterer accept tracklet information and assign a cluster
    // label to each tracklet by voting.

    // Matrix T in float-typed real numbers.
    cv::Mat T_float;
    // List of cluster IDs for face tracklets.
    std::vector<int> cluster_ids;
    // Clusterer object for faces.
    ugproj::FaceClusterer clusterer(cfg);

    // Since cv::kmeans() only accepts matrix in CV_32F, T should be converted.
    T_float.create(T.size(), CV_32FC1);
    T.convertTo(T_float, CV_32FC1);
    clusterer.do_clustering(T_float, tracklets, &cluster_ids);

    // == End of normalized spectral clustering. ==============================

    // Writes the visualization of result of clustering to multiple files.
    ugproj::FaceClustersVisualizer visualizer(cfg, &writer);
    visualizer.visualize(tracked_positions, tracklets,
                         cfg.clustering.k, cluster_ids);
  } catch (std::exception*) {
    return 1;
  }
  return 0;
}
